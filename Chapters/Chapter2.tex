\chapter{Introducción específica} % Main chapter title

\label{Chapter2}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
En este capítulo se desarrollan las partes constituyentes del dispositivo de adquisición de señales neurofisiológicas, se introduce a su hardware y al stack bluetooth. Adicionalmente se muestran las herramientas de desarrollo utilizadas en el proyecto.

\section{Hardware del DASN}
\label{sec:ejemplo}
El DASN está integrado en una sola placa y es un dispositivo portátil alimentado por baterías. Su arquitectura está basada en dos circuitos integrados principales, el microcontrolador CC2640R2 y el analog front end ADS1299. En la figura \ref{fig:diagBloquesHardware} podemos ver un diagrama en bloques del hardware.

\vspace{1cm}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/DiagramaEnBloquesHardware.png}
	\caption{Diagrama en bloques del hardware.}
	\label{fig:diagBloquesHardware}
\end{figure}

\vspace{1cm}

\subsection{Circuito de entrada}
El circuito de entrada del DASN está basado en un circuito integrado ADS1299 [Ref], el cual es un \textit{Analog front end} (AFE). Los AFE son dispositivos que incorporan la parte analógica para el acondicionamiento de la señal y el conversor analógico digital para poder digitalizar la señal y leerla desde un microcontrolador. En particular el ADS1299 es un dispositivo de 8 canales, 24 bits por canal, conversión analógica digital zigma delta simultánea, con amplificadores de ganancia programable y un circuito multiplexor que permite conectar las entradas de múltiples formas que lo hacen ideal para el registro de biopotenciales y en particular de señales de EEG. En la figura \ref{fig:diagBloquesADS1299} podemos ver un diagrama en bloques del ADS1299

\vspace{1cm}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/DiagramaEnBloquesADS1299.png}
	\caption{Diagrama en bloques del ADS1299.}
	\label{fig:diagBloquesADS1299}
\end{figure}

\vspace{1cm}

El ADS1299 posee un puerto de comunicación SPI. Adicionalmente se dispone de señales de control para poder configurar y controlar el dispositivo. El microcontrolador del DASN está conectado a todas estas interfaces de control del ADS1299.

El DASN posee siete canales idénticos, los cuales solo poseen un filtro de radiofrecuencia entre el paciente y el AFE. El octavo canal, es un canal de potenciales evocados, los potenicales evocados son señales con amplitudes menores a 1 uVpp, lo que hace imposible medirlos con el ADS1299 ya que el ruido reflejado a la entrada del dispositivo es de 1 uVpp. Para solucionar este inconveniente el DASN incorpora un circuito amplificador de alto rechazo de modo común, el cual acondiciona la señal de potenciales evocados a niveles que puedan ser adquiridos con el ADS1299. 

\subsection{Microcontrolador y comunicación inalámbrica}
El DASN posee un microcontrolador CC2640R2, el cual tiene una arquitectura Arm® Cortex®-M3. Este microcontrolador posee integrado un \textit{tranceiver} de 2.4 GHz compatible con la tecnología bluetooth de baja energía 5.1 y versiones anteriores del stack bluetooth [REF]. El hecho de tener este tipo de microcontrolador con el \textit{tranceiver} integrado permite configurar el stack bluetooth por completo, con lo que se logran mejores prestaciones en consumo y ancho de banda al poder elegir el protocolo de comunicación y modo de trabajo. La placa del DASN posee una antena tipo F [REF] integrada en el circuito impreso y también ofrece la posibilidad de conectar una antena externa. 

\subsection{Conceptos básicos del stack bluetooth 5.0}
Se darán algunos conceptos básicos sobre el stack bluetooth ya que ayudarán a entender las configuraciones realizadas que se verán en el siguiente capítulo. Usaré los nombres en inglés ya que muchos términos no tienen traducción y la mayoría de la bibliografía así los referencia. El bluetooth de baja energía, también conocido por sus siglas en inglés como BLE, se divide en distintas capas. La aplicación de usuario entra en contacto con las dos capas superiores del stack bluetooth, la capa GAP y la capa GATT. A través de estas capas es que el software del DASN configura y maneja la comunicación BLE, por esta razón aborde con un poco más de profundidad estos temas.

\subsubsection{Capa GAP}
La capa GAP del stack bluetooth es responsable de las conexiones. De acuerdo a la definición de esta capa un dispositivo bluetooth se puede encontrar en uno de los siguientes estados:

\begin{itemize}
\item \textit{Standby}: el dispositivo se encuentra en el estado inactivo inicial al reiniciarse.
\item \textit{Advertising}: El dispositivo se anuncia con datos específicos que le permiten a cualquier dispositivo saber que es un dispositivo conectable (este anuncio contiene la dirección del dispositivo y puede contener algunos datos adicionales, como el nombre del dispositivo).
\item \textit{Scanning}: En este estado se escuchan los mensajes enviados por algún \textit{advertiser}.
\item \textit{Initiating}: En este estado se inicia la conexión, pero el \textit{advertiser} es quien dependiendo los datos enviados por el \textit{initiator} acepta o no la conexión.
\item Connected: Cuando se establece una conexión ambos dispositivos pasan a estar en este estado.
\end{itemize}

A su vez, la capa GAP define cuatro roles para los dispositivos [ref]:

\begin{itemize}
\item \textit{Broadcaster}: el dispositivo es un anunciante que no se puede conectar.
\item \textit{Observer}: el dispositivo busca anuncios pero no puede iniciar conexiones.
\item \textit{Peripheral}: el dispositivo es un anunciante que se puede conectar y funciona como \item peripheral en una conexión de una sola capa de enlace.
\item \textit{Central}: el dispositivo busca anuncios e inicia conexiones y funciona como central en una o varias conexiones.
\end{itemize}

\subsubsection{Capa GATT}
La capa GATT es usada por la aplicación para el envío y recepción de los datos. Los datos son pasados y almacenados desde la aplicación de usuario al \textit{stack} bluetooth en forma de características. La capa GATT define los siguientes roles para los dispositivos que se encuentran conectados:
\begin{itemize}
\item GATT \textit{server}: Es el dispositivo que tiene la característica a ser leída o escrita por un GATT \textit{client}.
\item GATT \textit{client}: Es el dispositivo que lee o escribe en la característica de un GATT \textit{server}.
\end{itemize}

Los roles de la capa GATT (\textit{client} o \textit{server}) son independientes de los roles de la capa GAP (\textit{peripheral} o \textit{central}). Un \textit{peripheral} puede ser tanto un GATT \textit{client} como un GATT \textit{server}, y lo mismo ocurre con un \textit{central}.

Es importante destacar que el protocolo de comunicación BLE funciona por conexiones, cuando se tiene un nuevo dato no se transmite sino que se escribe en la característica para que el otro dispositivo que está conectado pueda ir a leerla. 

\subsection{Requerimientos}

\begin{enumerate}
	\item \textbf{Requerimientos de interfaces externas}
		\begin{enumerate}
			\item El software deberá comunicarse con el equipo de registro utilizando una interfaz BLE 5.0.
			\item El software deberá comunicarse con el equipo de registro utilizando una interfaz RS485. 
			\item El software deberá indicar mediante el led \#1 que está transmitiendo las señales adquiridas de forma inalámbrica o cableada. 
			\item El software deberá indicar mediante el led \#2 si está encendido o apagado. También deberá indicar con el mismo led \#2 si entra en el modo pairing BLE.
			\item El software deberá manejar una salida para sincronizar la adquisición con un estimulador externo (dispositivo externo como slave). La salida deberá poder configurarse entre normal bajo y normal alto. El pulso deberá poder configurarse entre 5 anchos de pulso diferentes (0,1 ms; 0,5 ms; 1 ms; 5 ms; 10 ms). 
			\item El software deberá manejar una entrada para sincronizar la adquisición con un estimulador externo (dispositivo externo como master). La detección deberá ser por flanco y se deberá poder configurar si el flanco es de subida o de bajada.
			\item El software deberá manejar el pulsador que servirá para encender el dispositivo y para realizar el pairing BLE.
			\item El software deberá generar la señal de impedancia para los canales de potenciales evocados.
			\item El software deberá medir el estado de las baterías con el ADC interno del MCU.
		\end{enumerate}
	\item \textbf{Requerimientos funcionales}
		\begin{enumerate}
			\item El software deberá configurar la frecuencia de muestreo de la señal adquirida entre 7 diferentes valores ( el ADC de ''EEG-FrontEnd\_v1.x.0.SchDoc” ofrece 250 Hz, 500 Hz, 1000 Hz, 2000 Hz, 4000 Hz, 8000 Hz y 16000 Hz).
			\item El software deberá poder adquirir de 1 a 8 canales simultáneos.
			\item Mediante comandos recibidos por BLE 5.0 o RS485 el software deberá poder iniciar y parar la adquisición.
			\item El software deberá configurar la ganancia de amplificación de cada canal entre 7 diferentes valores ( el ADC de ''EEG-FrontEnd\_v1.x.0.SchDoc” ofrece 1, 2, 4, 6, 8, 12 y 24).
			\item El software deberá configurar el ADC para usar una tipología de entrada diferencial o referencial.
			\item El software deberá medir la impedancia de los electrodos con una señal de medición de impedancia cuya frecuencia deberá ser de 7,8 Hz o 31,2 Hz.
			\item El software deberá seleccionar a qué electrodos le inyecta la señal de medición de impedancia.
			\item El software deberá seleccionar para cada electrodo si usa la señal de impedancia generada por el ADC o la generada por el MCU.
			\item El software deberá enviar la siguiente información de autodiagnóstico: temperatura del ADC, valor de las tensiones del ADC y frecuencia del clock del ADC.
			\item El software deberá prender y apagar el equipo con una pulsación corta del botón, pulsación menor a 1 segundo.
			\item El software deberá entrar en el modo de apareo de la comunicación BLE con una pulsación larga del botón, pulsación mayor a 4 segundos.
			\item Luego de 1 minuto de inactividad, el software deberá entrar a un modo de bajo consumo de energía. Para esto deberá apagar el ADC, el transceiver RS485 y la alimentación de todos los periféricos externos al MCU.
			\item El software deberá manejar una comunicación RS485 hasta 3 MBd.
			\item El software deberá poder recibir comandos mientras está transmitiendo las señales adquiridas.

		\end{enumerate}
	\item \textbf{Requerimientos de documentación}
		\begin{enumerate}
			\item La documentación debe cumplir los requisitos de la norma ISO 62304.
			\item Toda la documentación del proyecto se almacenará bajo un sistema de control de versiones GIT.
			\item Toda la documentación del código se realizará utilizando la herramienta Doxygen.
			\item Se deberá realizar un informe de avance del proyecto en el séptimo mes de trabajo
			\item Se deberá realizar la memoria técnica del trabajo final con la plantilla elaborada por la cátedra de gestión de proyecto.
		\end{enumerate}
%	\item \textbf{Requerimientos futuros}
%		\begin{enumerate}	
%			\item En el futuro se prevé diseñar un hardware con hasta 32 canales de adquisición.
			
%		\end{enumerate}
\end{enumerate}

\subsection{Herramientas de desarrollo}
Para el desarrollo del firmware se utilizó el entorno de desarrollo integrado (IDE por sus siglas en inglés de Integrated Development Environment) Code Composer Studio (CCS) version: 10.4.0.00006 y el kit de desarrollo de software (SDK por sus siglas en inglés de Software Development Kit) SimpleLink CC2640R2 SDK: 5.10.00.02 ambos de Texas Instrument. 

Como plataforma de hardware se dispuso de 2 placas de desarrollo LAUNCHXL-CC2640R2 [REF]. En la figura \ref{fig:kitDesarrolloCC2640R2} podemos ver una de estas placas. Estas placas fueron de mucha utilidad para comenzar a familiarizarse con el dispositivo y las herramientas. 

\vspace{1cm}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/LaunchpadCC2640R2.png}
	\caption{Kit de desarrollo launchpad CC2640R2.}
	\label{fig:kitDesarrolloCC2640R2}
\end{figure}

\vspace{1cm}
